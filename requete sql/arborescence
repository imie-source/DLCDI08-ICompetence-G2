--voir ici http://docs.postgresql.fr/9.1/queries-with.html 
WITH RECURSIVE parcourt_arbo(id_competence, libelle, niveau, chemin) AS (
					--1. terme non-récursif
					SELECT competence.id_comp, competence.libelle_comp, 0,	ARRAY[competence.id_comp] AS "array"
					FROM competence
					WHERE competence.id_comp_fait_partie IS NULL
					--2.Union ALL (voir ici http://docs.postgresqlfr.org/9.1/queries-union.html ) : ajoute les lignes de la seconde requête à la première requête
					UNION ALL 
					--3.Terme récursif
					SELECT precedent.id_comp, precedent.libelle_comp, debut.niveau + 1, debut.chemin || precedent.id_comp
					FROM competence precedent
					JOIN parcourt_arbo debut ON debut.id_competence = precedent.id_comp_fait_partie
			)
--4.SELECT des infos dont on a besoin
SELECT parcourt_arbo.id_competence, parcourt_arbo.libelle, parcourt_arbo.niveau, parcourt_arbo.chemin
FROM parcourt_arbo
-- On trie par chemin et par niveau. On a  ainsi l'arborescence des compétences qui apparait dans le chemin (c'est un tableau )et dans les niveaux. ex : 
-- 3;"Web";0;"{3}"
-- 10;"Javascript";1;"{3,10}"
-- 11;"PHP 5";1;"{3,11}"
-- 14;"CURL";2;"{3,11,14}"
-- 15;"fonctions curl";3;"{3,11,14,15}"
-- 16;"curl_close";4;"{3,11,14,15,16}"
-- 12;"Jquery";1;"{3,12}"
-- 4;"Administration réseaux";0;"{4}"
-- 13;"TCP/IP";1;"{4,13}"
-- 17;"JAVA";0;"{17}"
-- 18;"JEE";1;"{17,18}"
ORDER BY parcourt_arbo.chemin, array_dims(parcourt_arbo.chemin), parcourt_arbo.niveau;
